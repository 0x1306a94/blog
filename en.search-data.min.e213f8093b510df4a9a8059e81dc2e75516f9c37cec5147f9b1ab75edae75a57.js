'use strict';(function(){const t={cache:!0};t.doc={id:'id',field:['title','content'],store:['title','href']};const e=FlexSearch.create('balance',t);window.bookSearchIndex=e,e.add({id:0,href:'/docs/ios/ui/ch02/02/',title:"全屏Feed ScrollView嵌套时滑动问题",content:"最近在做类似抖音全屏视频Feed的需求,然后其中需要展示最新的部分评论,类似于直播中的评论列表.然后就理所当然的外面是一个UICollectionView, cell里面再嵌套UICollectionView\n从上面视频可以看出, 内层的UICollectionView在其顶部或者底部滑动时会直接响应外层的UICollectionView, 也就导致内层的UICollectionView失去了bounces效果 同时内层UICollectionView在滑动还会修改外层UICollectionView滑动 解决方案1,经过群友C指点 首先解决在内层UICollectionView区域触发滑动时不让外层UICollectionView响应, 子类化外层UICollectionView, 重写-gestureRecognizerShouldBegin: @interface ExternalCollectionView : UICollectionView @end @implementation ExternalCollectionView - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer { CGPoint location = [gestureRecognizer locationInView:self]; UIView *hitView = [self hitTest:location withEvent:nil]; while (hitView != nil) { if (hitView == self) { break; } if ([hitView isKindOfClass:UIScrollView.class]) { return NO; } hitView = [hitView superview]; } return [super gestureRecognizerShouldBegin:gestureRecognizer]; } @end 解决内层,同样子类化内层UICollectionView @interface InnerCustomCollectionView : UICollectionView @end @implementation InnerCustomCollectionView // 私有API - (UIScrollView *)_containingScrollView { // 当出现嵌套时,内层滑动到底或者到顶时,会修改外层的 contentOffset, 从而内层的也就失去了 bounces 效果 return nil; } @end 解决方案2, 逆向分析微信 通过Lookin查看微信的视图层级, 可以看出也是cell里面嵌套,但微信不同的是嵌套不是两层,而是多了一层, 也就是在内层的IM外面又套了一层不能滑动的UIScrollView,然后就可以直接解决上面的两个问题,无需其他黑科技或者处理 "}),e.add({id:1,href:'/docs/llvm/ch01/01/',title:"自定义 LLVM PASS 实现 函数耗时插桩统计",content:"下载源码 mkdir LLVM cd LLVM wget https://github.com/llvm/llvm-project/archive/llvmorg-11.0.0.zip unzip llvmorg-11.0.0.zip 编写编译脚本 在 LLVM 目录下,创建一个build.sh文件,拷贝下面内容 #!/usr/bin/env bash set -e set -o pipefail set -u ROOT_DIR=`pwd` SOURCE_CODE_DIR=$ROOT_DIR/llvm-project-llvmorg-11.0.0 BUILD_DIR=$ROOT_DIR/build_dir LLVM_BUILD_DIR=$BUILD_DIR/build_llvm LLVM_OUT_DIR=$BUILD_DIR/build_llvm_out CLANG_BUILD_DIR=$BUILD_DIR/build_clang CLANG_OUT_DIR=$BUILD_DIR/build_clang_out XCODE_BUILD_DIR=$BUILD_DIR/build_xcode XCODE_OUT_DIR=$BUILD_DIR/build_xcode_out function build_llvm() { echo \u0026#34;generate llvm ninja build config ...\u0026#34; cd $LLVM_BUILD_DIR cmake -G \u0026#34;Ninja\u0026#34; \\ -DCMAKE_OSX_DEPLOYMENT_TARGET=\u0026#34;10.14\u0026#34; \\ -DCMAKE_OSX_SYSROOT=\u0026#34;macosx\u0026#34; \\ -DCMAKE_OSX_ARCHITECTURES=\u0026#39;x86_64\u0026#39; \\ -DLLVM_TARGETS_TO_BUILD=\u0026#34;X86\u0026#34; \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_INSTALL_PREFIX=$LLVM_OUT_DIR \\ $SOURCE_CODE_DIR/llvm echo \u0026#34;ninja build llvm ...\u0026#34; ninja install } function build_clang() { echo \u0026#34;generate clang ninja build config ...\u0026#34; cd $CLANG_BUILD_DIR cmake -G \u0026#34;Ninja\u0026#34; \\ -DCMAKE_PREFIX_PATH=$LLVM_OUT_DIR/lib/cmake/llvm \\ -DCMAKE_OSX_DEPLOYMENT_TARGET=\u0026#34;10.14\u0026#34; \\ -DCMAKE_OSX_SYSROOT=\u0026#34;macosx\u0026#34; \\ -DCMAKE_OSX_ARCHITECTURES=\u0026#39;x86_64\u0026#39; \\ -DLLVM_TARGETS_TO_BUILD=\u0026#34;X86\u0026#34; \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_INSTALL_PREFIX=$CLANG_OUT_DIR \\ $SOURCE_CODE_DIR/clang echo \u0026#34;ninja build clang ...\u0026#34; ninja install } function generate_xcode_project() { cd $XCODE_BUILD_DIR cmake -G \u0026#34;Xcode\u0026#34; \\ -DCMAKE_OSX_DEPLOYMENT_TARGET=\u0026#34;10.14\u0026#34; \\ -DCMAKE_OSX_SYSROOT=\u0026#34;macosx\u0026#34; \\ -DCMAKE_OSX_ARCHITECTURES=\u0026#39;x86_64\u0026#39; \\ -DLLVM_TARGETS_TO_BUILD=\u0026#34;X86\u0026#34; \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_INSTALL_PREFIX=$XCODE_OUT_DIR \\ $SOURCE_CODE_DIR/llvm } function clear_build() { echo \u0026#34;clear build dir\u0026#34; rm -rf $BUILD_DIR } function usage() { echo \u0026#34;Usage:\u0026#34; echo \u0026#34;build.sh -b -x\u0026#34; echo \u0026#34;Description:\u0026#34; echo \u0026#34;-b, build llvm and clang\u0026#34; echo \u0026#34;-x, generate xcode project\u0026#34; echo \u0026#34;-c, clear build dir\u0026#34; exit 0 } function onCtrlC () { clear_build exit 0 } BUILD_FLAG=0 GENERATE_XCODE_FLAG=0 CLEAR_BUILD_FLAG=0 while getopts \u0026#39;hbxc\u0026#39; OPT; do case $OPT in b) BUILD_FLAG=1;; x) GENERATE_XCODE_FLAG=1;; c) CLEAR_BUILD_FLAG=1;; h) usage;; ?) usage;; esac done if [[ $CLEAR_BUILD_FLAG == 1 ]]; then clear_build fi if [[ $BUILD_FLAG == 1 ]]; then # trap \u0026#39;onCtrlC\u0026#39; INT startTime_s=`date +%s` if [[ $GENERATE_XCODE_FLAG == 1 ]]; then mkdir -p $XCODE_BUILD_DIR generate_xcode_project else mkdir -p $LLVM_BUILD_DIR $CLANG_BUILD_DIR build_llvm build_clang fi endTime_s=`date +%s` sumTime=$[ $endTime_s - $startTime_s ] echo \u0026#34;开始: $(date -r $startTime_s +%Y%m%d-%H:%M:%S)\u0026#34; echo \u0026#34;结束: $(date -r $endTime_s +%Y%m%d-%H:%M:%S)\u0026#34; hour=$[ $sumTime / 3600 ] minutes=$[ ($sumTime - ($hour * 3600)) / 60 ] seconds=$[ ($sumTime - ($hour * 3600)) % 60 ] echo \u0026#34;耗时：$hour:$minutes:$seconds\u0026#34; fi 创建PASS工程 进入llvm-project-llvmorg-11.0.0/llvm/lib/Transforms 目录 将 Hello 目录拷贝一份,并重命名为 FunctionCallTime 在 llvm-project-llvmorg-11.0.0/llvm/lib/Transforms/CMakeLists.txt 后面追加一行 add_subdirectory(FunctionCallTime) 在 llvm-project-llvmorg-11.0.0/llvm/lib/Transforms/LLVMBuild.txt subdirectories 后面追加 FunctionCallTime 修改 FunctionCallTime/CMakeLists.txt 为下面内容 # If we don\u0026#39;t need RTTI or EH, there\u0026#39;s no reason to export anything # from the hello plugin. if( NOT LLVM_REQUIRES_RTTI ) if( NOT LLVM_REQUIRES_EH ) set(LLVM_EXPORTED_SYMBOL_FILE ${CMAKE_CURRENT_SOURCE_DIR}/FunctionCallTime.exports) endif() endif() if(WIN32 OR CYGWIN) set(LLVM_LINK_COMPONENTS Core Support) endif() set(LLVM_LINK_COMPONENTS Demangle) add_llvm_library( LLVMFunctionCallTime MODULE BUILDTREE_ONLY FunctionCallTime.cpp DEPENDS intrinsics_gen PLUGIN_TOOL opt ) 将 Hello.cpp 重命名为 FunctionCallTime.cpp, Hello.exports 重命名为 FunctionCallTime.exports 将FunctionCallTime.cpp 内容替换为下面 // // function_call_time.cpp // function-call-time // // Created by king on 2020/12/18. // #include \u0026lt;iostream\u0026gt; #include \u0026#34;llvm/ADT/Statistic.h\u0026#34; #include \u0026#34;llvm/Demangle/Demangle.h\u0026#34; #include \u0026#34;llvm/IR/BasicBlock.h\u0026#34; #include \u0026#34;llvm/IR/Constants.h\u0026#34; #include \u0026#34;llvm/IR/Function.h\u0026#34; #include \u0026#34;llvm/IR/IRBuilder.h\u0026#34; #include \u0026#34;llvm/IR/Instruction.h\u0026#34; #include \u0026#34;llvm/IR/Instructions.h\u0026#34; #include \u0026#34;llvm/IR/LegacyPassManager.h\u0026#34; #include \u0026#34;llvm/IR/Module.h\u0026#34; #include \u0026#34;llvm/IR/Value.h\u0026#34; #include \u0026#34;llvm/Pass.h\u0026#34; #include \u0026#34;llvm/Support/raw_ostream.h\u0026#34; #include \u0026#34;llvm/Transforms/IPO/PassManagerBuilder.h\u0026#34; using namespace llvm; namespace { struct FunctionCallTimePass : public FunctionPass { static char ID; static StringRef InsertFuncNamePrefix; static StringRef BeginFuncName; static StringRef EndFuncName; FunctionCallTimePass() : FunctionPass(ID) {} bool runOnFunction(Function \u0026amp;F) override { if (F.empty()) { return false; } std::string annotation = readAnnotate(\u0026amp;F); auto funcName = F.getName(); // 可以通过 __attribute__((__annotate__((\u0026#34;ignore_appletrace\u0026#34;)))) // 忽略当前函数 if (annotation.length() \u0026gt; 0 \u0026amp;\u0026amp; StringRef(annotation).contains(\u0026#34;ignore_appletrace\u0026#34;)) { errs() \u0026lt;\u0026lt; \u0026#34;function-call-time: \u0026#34; \u0026lt;\u0026lt; funcName \u0026lt;\u0026lt; \u0026#34; 忽略 annotation\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return false; } // Objective-C 方法前面有 \\x01 if (funcName.front() == \u0026#39;\\x01\u0026#39;) { funcName = funcName.drop_front(); } if (funcName.startswith(\u0026#34;__Z\u0026#34;) || funcName.startswith(\u0026#34;_Z\u0026#34;)) { // C++ 函数 std::string str = funcName.str(); std::string demangled = demangle(str); funcName = StringRef(demangled); } // 将统计代码调用过滤掉 if (funcName.startswith(\u0026#34;appletrace\u0026#34;)) { return false; } // 如果是插桩的函数直接跳过 if (F.getName().startswith(FunctionCallTimePass::InsertFuncNamePrefix)) { return false; } // 只统计 Objective-C 方法调用 if (funcName.startswith(\u0026#34;+[\u0026#34;) || funcName.startswith(\u0026#34;-[\u0026#34;)) { // 2. 插入开始 if (!insertBeginInst(F)) { return false; } // 3. 插入结束 insertEndInst(F); return false; } return false; } private: std::string readAnnotate(Function *f) { std::string annotation = \u0026#34;\u0026#34;; // Get annotation variable GlobalVariable *glob = f-\u0026gt;getParent()-\u0026gt;getGlobalVariable(\u0026#34;llvm.global.annotations\u0026#34;); if (glob != NULL) { // Get the array if (ConstantArray *ca = dyn_cast\u0026lt;ConstantArray\u0026gt;(glob-\u0026gt;getInitializer())) { for (unsigned i = 0; i \u0026lt; ca-\u0026gt;getNumOperands(); ++i) { // Get the struct if (ConstantStruct *structAn = dyn_cast\u0026lt;ConstantStruct\u0026gt;(ca-\u0026gt;getOperand(i))) { if (ConstantExpr *expr = dyn_cast\u0026lt;ConstantExpr\u0026gt;(structAn-\u0026gt;getOperand(0))) { // If it\u0026#39;s a bitcast we can check if the annotation is concerning // the current function if (expr-\u0026gt;getOpcode() == Instruction::BitCast \u0026amp;\u0026amp; expr-\u0026gt;getOperand(0) == f) { ConstantExpr *note = cast\u0026lt;ConstantExpr\u0026gt;(structAn-\u0026gt;getOperand(1)); // If it\u0026#39;s a GetElementPtr, that means we found the variable // containing the annotations if (note-\u0026gt;getOpcode() == Instruction::GetElementPtr) { if (GlobalVariable *annoteStr = dyn_cast\u0026lt;GlobalVariable\u0026gt;(note-\u0026gt;getOperand(0))) { if (ConstantDataSequential *data = dyn_cast\u0026lt;ConstantDataSequential\u0026gt;( annoteStr-\u0026gt;getInitializer())) { if (data-\u0026gt;isString()) { annotation += data-\u0026gt;getAsString().lower() + \u0026#34; \u0026#34;; } } } } } } } } } } return annotation; } bool insertBeginInst(Function \u0026amp;F) { // 0.函数最开始的BasicBlock LLVMContext \u0026amp;context = F.getParent()-\u0026gt;getContext(); BasicBlock \u0026amp;BB = F.getEntryBlock(); // 1. 获取要插入的函数 FunctionCallee beginFun = F.getParent()-\u0026gt;getOrInsertFunction( FunctionCallTimePass::BeginFuncName, FunctionType::get(Type::getVoidTy(context), {Type::getInt8PtrTy(context)}, false)); errs() \u0026lt;\u0026lt; \u0026#34;function-call-time: \u0026#34; \u0026lt;\u0026lt; BB.getParent()-\u0026gt;getName() \u0026lt;\u0026lt; \u0026#34; begin\\n\u0026#34;; // 2. 构造函数 CallInst *inst = nullptr; IRBuilder\u0026lt;\u0026gt; builder(\u0026amp;BB); IRBuilder\u0026lt;\u0026gt; callBuilder(context); Value *name = builder.CreateGlobalStringPtr(BB.getParent()-\u0026gt;getName()); inst = callBuilder.CreateCall(beginFun, {name}); if (!inst) { llvm::errs() \u0026lt;\u0026lt; \u0026#34;Create First CallInst Failed\\n\u0026#34;; return false; } // 3. 获取函数开始的第一条指令 Instruction *beginInst = dyn_cast\u0026lt;Instruction\u0026gt;(BB.begin()); // 4. 将inst插入 inst-\u0026gt;insertBefore(beginInst); return true; } void insertEndInst(Function \u0026amp;F) { LLVMContext \u0026amp;context = F.getParent()-\u0026gt;getContext(); for (Function::iterator I = F.begin(), E = F.end(); I != E; ++I) { // 函数结尾的BasicBlock BasicBlock \u0026amp;BB = *I; for (BasicBlock::iterator I = BB.begin(), E = BB.end(); I != E; ++I) { ReturnInst *IST = dyn_cast\u0026lt;ReturnInst\u0026gt;(I); if (!IST) continue; // end_func 类型 FunctionType *endFuncType = FunctionType::get( Type::getVoidTy(context), {Type::getInt8PtrTy(context)}, false); // end_func FunctionCallee endFunc = BB.getModule()-\u0026gt;getOrInsertFunction( FunctionCallTimePass::EndFuncName, endFuncType); // 构造end_func IRBuilder\u0026lt;\u0026gt; builder(\u0026amp;BB); IRBuilder\u0026lt;\u0026gt; callBuilder(context); Value *name = builder.CreateGlobalStringPtr(BB.getParent()-\u0026gt;getName()); CallInst *endCI = callBuilder.CreateCall(endFunc, {name}); // 插入end_func(struction) endCI-\u0026gt;insertBefore(IST); errs() \u0026lt;\u0026lt; \u0026#34;function-call-time: \u0026#34; \u0026lt;\u0026lt; BB.getParent()-\u0026gt;getName() \u0026lt;\u0026lt; \u0026#34; end\\n\u0026#34;; } } } }; } // namespace char FunctionCallTimePass::ID = 0; StringRef FunctionCallTimePass::InsertFuncNamePrefix = \u0026#34;_kk_APT\u0026#34;; StringRef FunctionCallTimePass::BeginFuncName = \u0026#34;_kk_APTBeginSection\u0026#34;; StringRef FunctionCallTimePass::EndFuncName = \u0026#34;_kk_APTEndSection\u0026#34;; // 注册给 opt // opt -load LLVMFunctionCallTime.dylib -function-call-time xx.bc static RegisterPass\u0026lt;FunctionCallTimePass\u0026gt; X(\u0026#34;function-call-time\u0026#34;, \u0026#34;Function calls take time to collect\u0026#34;, false, false); // 注册给 clang 通过 -Xclang -load -Xclang LLVMFunctionCallTime.dylib static RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible, [](const PassManagerBuilder \u0026amp;Builder, legacy::PassManagerBase \u0026amp;PM) { PM.add(new FunctionCallTimePass()); }); 创建Xcode工程 需要安装cmake 进入 LLVM 目录下执行 chmod +x ./build.sh # 只需要执行一次 ./build.sh -b -x 执行成功后,会在LLVM目录下生成build_dir目录 build_dir └── build_xcode ├── CMakeCache.txt ├── CMakeFiles ├── CMakeScripts ├── CPackConfig.cmake ├── CPackSourceConfig.cmake ├── Debug ├── LLVM.xcodeproj ├── LLVMBuild.cmake ├── MinSizeRel ├── RelWithDebInfo ├── Release ├── benchmarks ├── build ├── cmake ├── cmake_install.cmake ├── docs ├── examples ├── include ├── lib ├── llvm.spec ├── projects ├── runtimes ├── test ├── tools ├── unittests └── utils 打开 LLVM.xcodeproj, 会提示创建scheme, 可以选择自动,也可以选择手动, Pass scheme 为LLVMFunctionCallTime FunctionCallTime Pass target 在 Loadable modules 下面 选择LLVMFunctionCallTime command + b 进行编译 默认是Debug模式,所以LLVMFunctionCallTime.dylib产物在build_dir/build_xcode/Debug/lib/LLVMFunctionCallTime.dylib 使用 Pass 由于Xcode内置的clang,不支持加载自定义插件,所以直接从LLVM Project Github 仓库下载编译好的 由于开始下载的源码为LLVM 11.0.0, 所以为了一致也是下载相同的版本 wget https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/clang+llvm-11.0.0-x86_64-apple-darwin.tar.xz mkdir -p ./clang-11.0.0 tar xf clang+llvm-11.0.0-x86_64-apple-darwin.tar.xz -C ./clang-11.0.0 --strip-components 1 下载 everettjf/AppleTrace 将 appletrace.h appletrace.mm 拖入你的工程中 将APTBeginSection APTEndSection APTSyncWait 修改为 _kk_APTBeginSection _kk_APTEndSection _kk_APTSyncWait,为了便于区分在Pass里面指定了 _kk_APT前缀 将appletrace.mm 中WriteSection 改为如下 void WriteSection(const char *name, const char *ph) { pthread_t thread = pthread_self(); __uint64_t thread_id = 0; pthread_threadid_np(thread, \u0026amp;thread_id); uint64_t time = mach_absolute_time() * timeinfo_.numer / timeinfo_.denom; uint64_t elapsed = (time - begin_) / 1000.0; if (main_thread_id == 0 \u0026amp;\u0026amp; pthread_main_np() != 0) { main_thread_id = thread_id; } if (main_thread_id == thread_id) { thread_id = 0; // just make main thread id zero } // 通过 llvm pass 插桩传递过来的 name 最前有个 \\0x1 所以需要特殊处理下 // 当然也可以直接在 pass 中处理好 NSString *str = nil; if (name[0] == \u0026#39;\\x01\u0026#39;) { str = [NSString stringWithFormat:@\u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;%s\\\u0026#34;,\\\u0026#34;cat\\\u0026#34;:\\\u0026#34;catname\\\u0026#34;,\\\u0026#34;ph\\\u0026#34;:\\\u0026#34;%s\\\u0026#34;,\\\u0026#34;pid\\\u0026#34;:666,\\\u0026#34;tid\\\u0026#34;:%llu,\\\u0026#34;ts\\\u0026#34;:%llu}\u0026#34;, name + 1, ph, thread_id, elapsed]; } else { str = [NSString stringWithFormat:@\u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;%s\\\u0026#34;,\\\u0026#34;cat\\\u0026#34;:\\\u0026#34;catname\\\u0026#34;,\\\u0026#34;ph\\\u0026#34;:\\\u0026#34;%s\\\u0026#34;,\\\u0026#34;pid\\\u0026#34;:666,\\\u0026#34;tid\\\u0026#34;:%llu,\\\u0026#34;ts\\\u0026#34;:%llu}\u0026#34;, name, ph, thread_id, elapsed]; } dispatch_async(queue_, ^{ log_.AddLine(str.UTF8String); }); } 在你的工程中创建一个xcconfig 文件,内容如下 // // Config.xcconfig // PageLinkDemo // // Created by king on 2020/12/18. // // Configuration settings file format documentation can be found at: // https://help.apple.com/xcode/#/dev745c5c974 LLVM_DIR = $HOME/Documents/LLVM # 修改为在你本机的实际路径 PASS_DYLIB = $(LLVM_DIR)/build_dir/build_xcode/Debug/lib/LLVMFunctionCallTime.dylib OTHER_CFLAGS = $(inherited) -Xclang -load -Xclang $(PASS_DYLIB) OTHER_CPLUSPLUSFLAGS = $(inherited) -Xclang -load -Xclang $(PASS_DYLIB) COMPILER_INDEX_STORE_ENABLE = NO CC = $(LLVM_DIR)/clang-11.0.0/bin/clang CXX = $(LLVM_DIR)clang-11.0.0/bin/clang++ 修改工程配置 然后进行编译,如果没有错误,则会在Xcode编译日志中可以看到相关日志,如下图 由于qmuidemo 依赖了 qmui 子工程,所以我将 appletrace.h appletrace.mm 放到了 qmui工程中,这样主工程和子工程则都能进行插桩 运行你的项目后,会在Xcode控制台看到如下输出 2020-12-20 14:49:32.530027+0800 qmuidemo[25684:1347559] log path = /Users/king/Library/Developer/CoreSimulator/Devices/71211D11-6169-4508-BBD8-B38958350C8F/data/Containers/Data/Application/46E933FE-D962-4355-9E0D-F8CBA44ABFA7/Library/appletracedata/trace.appletrace 使用everettjf/AppleTrace生成火焰图 通过上面输出的log path,将appletracedata目录拷贝到 下载的everettjf/AppleTrace中 将下载的everettjf/AppleTrace merge.py 中 run函数的while循环外面添加如下代码 self.output.seek(-2, os.SEEK_END) self.output.truncate() self.output.write(\u0026#39;\\n]\u0026#39;) 合并appletracedata目录下所有文件内容,输出为JSON文件 python merge.py -d ./appletracedata 下载依赖 sh get_catapult.sh 生成火焰图 HTML 文件 # 生成 python catapult/tracing/bin/trace2html appletracedata/trace.json --output=appletracedata/trace.html # 打开预览 open trace.html 预览 QMUIDemo 火焰图 使用Xcode 调试 Pass 需要通过opt调试 首先需要先编译好Pass 生成IR文件 clang -x objective-c++ -isysroot $(xcrun --sdk macosx --show-sdk-path) -S -emit-llvm -c xxx.m -o xx.ll 切换为opt scheme, 选择Edit Scheme 设置 opt的启动参数,如下 然后运行 opt, 由于opt依赖很多,所有需要编译很长时间,不过如果你是40万的Mac Pro,那么可能只需要几秒或者十几秒 这样就可以直接在Pass源码中下断点 LLVMFunctionCallTimePass 源码 参考 Writing an LLVM Pass Clang 插件统计方法耗时 "}),e.add({id:2,href:'/docs/ios/ui/ch01/01/',title:"实现抖音评论列表效果",content:"\n通过Lookin查看视图层级可得知: 首页是一个导航栏控制器, 其 rootViewController 为 AWEFeedRootViewController AWEFeedContainerViewController 为视频列表的控制器, 同时 AWEFeedContainerViewController 做为 AWEFeedRootViewController 的 childViewController AWECommentListViewController 为评论弹层, AWECommentListViewController 并未采用 addChildViewController 方式加入 AWEFeedContainerViewController 作为其 childViewController, 而是直接将 AWECommentListViewController.view 添加到 AWEFeedRootViewController.view AWECommentListViewController 的视图层级如下: baseView effectView 为 UIVisualEffectView 实现模糊效果 headerView tableView keyboardMaskView 当键盘弹出时,才显示,用于实现点击上半部分关闭键盘 commentInputView 底部输入框 抖音评论列表有以下效果: 无评论数据时,整个 baseView 区域可以通过手势往下滑动以关闭列表 有评论数据时,下滑tableView到顶时继续往下滑动,则会让baseView和commentInputView同步联动往下滑 同时还有两个细节个人认为没有处理好: 当往下联动后再往上滑动无法触发tableView继续往上滑动 当tableView已经往上滑动了一部分后,从headerView区域无法触发滑动,只能先通过tableView触发,然后激活联动处理 接下来通过逆向分析得知: 通过上面分析的视图层级,找到baseView, 发现baseView自身被添加了一个UIPanGestureRecognizer UIPanGestureRecognizer 的 target 为 AWECommentListViewController UIPanGestureRecognizer 的 action 为 AWECommentListViewController 的 selfPanned: UIPanGestureRecognizer 的 delegate 为 AWECommentListViewController 大致确定了整个联动处理是依靠baseView的手势和tableView自身的手势共同完成 iPhone:~ root# cycript -p Aweme cy# UIApp.keyWindow.rootViewController #\u0026#34;\u0026lt;AWETabBarController: 0x116283600\u0026gt;\u0026#34; cy# [#0x116a59520 subviews] @[#\u0026#34;\u0026lt;UIView: 0x115e3f7d0; frame = (0 0; 375 667); autoresize = W+H; layer = \u0026lt;CALayer: 0x282b1a7a0\u0026gt;\u0026gt;\u0026#34;,#\u0026#34;\u0026lt;UIView: 0x119063140; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = \u0026lt;NSArray: 0x2827722e0\u0026gt;; layer = \u0026lt;CALayer: 0x282af3ac0\u0026gt;\u0026gt;\u0026#34;] cy# [#0x119063140 subviews] @[#\u0026#34;\u0026lt;UIView: 0x11f16f720; frame = (0 180; 375 487); gestureRecognizers = \u0026lt;NSArray: 0x282773c60\u0026gt;; layer = \u0026lt;CALayer: 0x282a8fd00\u0026gt;\u0026gt;\u0026#34;,#\u0026#34;\u0026lt;UIView: 0x11f1d60d0; frame = (0 667; 375 200); layer = \u0026lt;CALayer: 0x282aa3b20\u0026gt;\u0026gt;\u0026#34;,#\u0026#34;\u0026lt;UIView: 0x11f1f3370; frame = (0 0; 375 667); alpha = 0; gestureRecognizers = \u0026lt;NSArray: 0x282755860\u0026gt;; layer = \u0026lt;CALayer: 0x282c6d720\u0026gt;\u0026gt;\u0026#34;,#\u0026#34;\u0026lt;AWECommentListInputView: 0x11f1f0110; frame = (0 618; 375 49); gestureRecognizers = \u0026lt;NSArray: 0x282765380\u0026gt;; layer = \u0026lt;CALayer: 0x282bc2080\u0026gt;\u0026gt;\u0026#34;] .... .... cy# [#0x11f16f720 gestureRecognizers] @[#\u0026#34;\u0026lt;UIPanGestureRecognizer: 0x12175a1c0; state = Possible; view = \u0026lt;UIView 0x11f16f720\u0026gt;; targets= \u0026lt;(\\n \\\u0026#34;(action=selfPanned:, target=\u0026lt;AWECommentListViewController 0x1163bd400\u0026gt;)\\\u0026#34;,\\n \\\u0026#34;(action=awe_UITracker_gestureRecognizer:, target=\u0026lt;UIView 0x11f16f720\u0026gt;)\\\u0026#34;\\n)\u0026gt;\u0026gt;\u0026#34;] cy# [#0x12175a1c0 delegate] #\u0026#34;\u0026lt;AWECommentListViewController: 0x1163bd400\u0026gt;\u0026#34; .... .... 写代码实现 没有具体去分析抖音的实现,所以接下来会通过自己的方法来实现抖音的效果,同时处理上面所提出的两个细节 创建一个继承自UITableView的CommentListTableView,并重写gestureRecognizerShouldBegin: // // CommentListTableView.m // TestTableView // // Created by 0x1306a94 on 2020/10/31. // Copyright © 2020 0x1306a94. All rights reserved. // #import \u0026#34;CommentListTableView.h\u0026#34; @implementation CommentListTableView - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer { if ([gestureRecognizer isKindOfClass:UIPanGestureRecognizer.class]) { UIPanGestureRecognizer *pan = (UIPanGestureRecognizer *)gestureRecognizer; CGPoint contentOffset = self.contentOffset; CGPoint velocity = [pan velocityInView:pan.view]; // CGAffineTransform transform = self.superview.transform; // if (transform.ty != 0) { // return NO; // } if (contentOffset.y == -self.contentInset.top) { NSLog(@\u0026#34;%@\u0026#34;, NSStringFromCGPoint(velocity)); // 关键点: 当前是最顶点, 不允许往下滑动 if (velocity.y \u0026gt; 0) { // 向下 return NO; } } } return YES; } @end 创建 CommentListViewController, 并构建对应的视图层级 // // CommentListViewController.m // TestTableView // // Created by 0x1306a94 on 2020/10/31. // Copyright © 2020 0x1306a94. All rights reserved. // #import \u0026#34;CommentListViewController.h\u0026#34; #import \u0026#34;CommentListTableView.h\u0026#34; @interface CommentListViewController () \u0026lt;UITableViewDataSource, UITableViewDelegate, UIGestureRecognizerDelegate\u0026gt; @property (nonatomic, strong) UIView *containerView; @property (nonatomic, strong) UIView *headerView; @property (nonatomic, strong) CommentListTableView *tableView; @property (nonatomic, assign) BOOL panGestureEnable; @end @implementation CommentListViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. self.view.backgroundColor = UIColor.clearColor; self.containerView = [[UIView alloc] initWithFrame:CGRectMake(0, CGRectGetHeight(UIScreen.mainScreen.bounds) * 0.3, CGRectGetWidth(UIScreen.mainScreen.bounds), CGRectGetHeight(UIScreen.mainScreen.bounds) * 0.7)]; self.containerView.backgroundColor = UIColor.orangeColor; self.containerView.layer.cornerRadius = 10; self.containerView.layer.maskedCorners = kCALayerMinXMinYCorner | kCALayerMaxXMinYCorner; self.containerView.layer.masksToBounds = YES; self.headerView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, CGRectGetWidth(self.containerView.bounds), 100)]; self.headerView.backgroundColor = UIColor.redColor; self.tableView = [[CommentListTableView alloc] initWithFrame:CGRectMake(0, 100, CGRectGetWidth(self.containerView.bounds), CGRectGetHeight(self.containerView.bounds) - 100) style:UITableViewStylePlain]; self.tableView.backgroundColor = UIColor.whiteColor; self.tableView.dataSource = self; self.tableView.delegate = self; [self.tableView registerClass:UITableViewCell.class forCellReuseIdentifier:@\u0026#34;cell\u0026#34;]; [self.view addSubview:self.containerView]; [self.containerView addSubview:self.headerView]; [self.containerView addSubview:self.tableView]; UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panGestureHandler:)]; pan.delegate = self; self.panGestureEnable = NO; [self.containerView addGestureRecognizer:pan]; self.view.hidden = YES; CGAffineTransform transform = CGAffineTransformMakeTranslation(0, CGRectGetHeight(self.containerView.frame)); self.containerView.transform = transform; } - (void)panGestureHandler:(UIPanGestureRecognizer *)pan { if (self.tableView.isDragging) { return; } switch (pan.state) { case UIGestureRecognizerStateBegan: { [pan setTranslation:CGPointZero inView:pan.view]; break; } case UIGestureRecognizerStateChanged: { CGPoint translation = [pan translationInView:pan.view]; CGPoint contentOffset = self.tableView.contentOffset; if (contentOffset.y \u0026gt; 0) { // 这段代码用于处理, tableView 已经往上滑动一部分后 // 从 headerView 区域 触发手势, 无法滑动 tableView // 还有另一个功能就是,用于修正 tableView contentOffset.y -= translation.y; [pan setTranslation:CGPointZero inView:pan.view]; [self.tableView setContentOffset:contentOffset animated:NO]; return; } // 如果去掉这段代码,会出现 突然往下跳动, 具体现象可以,注释掉这部分代码 if (contentOffset.y == 0.0 \u0026amp;\u0026amp; !self.panGestureEnable) { self.panGestureEnable = YES; [pan setTranslation:CGPointZero inView:pan.view]; return; } [self updatePresentedViewForTranslation:translation.y]; break; } case UIGestureRecognizerStateEnded: case UIGestureRecognizerStateFailed: { self.panGestureEnable = NO; CGAffineTransform curTransform = self.containerView.transform; CGAffineTransform transform = CGAffineTransformIdentity; // 200 这个临界值可以修改为自己项目合适的值 if (curTransform.ty \u0026gt;= 200) { [self hide]; } else { /* clang-format off */ [UIView animateWithDuration:0.6 delay:0 usingSpringWithDamping:1 initialSpringVelocity:1 options:UIViewAnimationOptionCurveEaseOut| UIViewAnimationOptionAllowUserInteraction animations:^{ self.containerView.transform = transform; } completion:^(BOOL finished) { }]; /* clang-format on */ } break; } default: break; } } #pragma mark - updatePresentedViewForTranslation - (void)updatePresentedViewForTranslation:(CGFloat)translation { if (translation \u0026lt; 0) { self.containerView.transform = CGAffineTransformIdentity; [self.tableView setContentOffset:CGPointMake(0, -translation) animated:NO]; return; } self.containerView.transform = CGAffineTransformMakeTranslation(0, translation); } #pragma mark - UIGestureRecognizerDelegate - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer { // 关键点: 允许同时识别多个手势 return YES; } #pragma mark - UITableViewDataSource - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return 100; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\u0026#34;cell\u0026#34;]; cell.textLabel.text = @(indexPath.row).stringValue; return cell; } #pragma mark - UIScrollViewDelegate - (void)scrollViewDidScroll:(UIScrollView *)scrollView { // 关键点: 当 tableView 下滑到顶以后, 交由 containerView 的手势处理 // 这样就不需要下滑到顶以后,需要松开手指 再次触发手势 if (scrollView.contentOffset.y \u0026lt;= -scrollView.contentInset.top \u0026amp;\u0026amp; scrollView.panGestureRecognizer.state == UIGestureRecognizerStateChanged) { NSLog(@\u0026#34;tableview top\u0026#34;); scrollView.panGestureRecognizer.state = UIGestureRecognizerStateEnded; [scrollView setContentOffset:CGPointZero animated:NO]; return; } } #pragma mark - public method - (void)show { self.view.hidden = NO; CGAffineTransform transform = CGAffineTransformIdentity; /* clang-format off */ [UIView animateWithDuration:0.6 delay:0 usingSpringWithDamping:1 initialSpringVelocity:1 options:UIViewAnimationOptionCurveEaseOut| UIViewAnimationOptionAllowUserInteraction animations:^{ self.containerView.transform = transform; } completion:^(BOOL finished) { }]; /* clang-format on */ } - (void)hide { CGAffineTransform transform = CGAffineTransformMakeTranslation(0, CGRectGetHeight(self.containerView.frame)); /* clang-format off */ [UIView animateWithDuration:0.6 delay:0 usingSpringWithDamping:1 initialSpringVelocity:1 options:UIViewAnimationOptionCurveEaseOut| UIViewAnimationOptionAllowUserInteraction animations:^{ self.containerView.transform = transform; } completion:^(BOOL finished) { if (finished) { self.view.hidden = YES; } }]; /* clang-format on */ } @end 无数据时,可以将tableView.scrollEnabled = NO demo 效果如下 "}),e.add({id:3,href:'/docs/ios/runtime/ch01/01/',title:"Objective C 关联对象原理",content:"如何使用? 首先需要导入 \u0026lt;objc/runtime.h\u0026gt; 头文件\n然后通过 runtime 如下 API\n// 为 object 设置关联值 OBJC_EXPORT void objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0); // 获取 object 关联值 OBJC_EXPORT id _Nullable objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0); // 移除 object 所有关联值 OBJC_EXPORT void objc_removeAssociatedObjects(id _Nonnull object) OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0); 示例代码一\n#import \u0026lt;Foundation/Foundation.h\u0026gt; #import \u0026lt;objc/runtime.h\u0026gt; @interface CustomObject : NSObject @end @implementation CustomObject @end int main(int argc, const char *argv[]) { CustomObject *obj = [[CustomObject alloc] init]; const char *key = \u0026#34;name\u0026#34;; NSString *value = @\u0026#34;0x1306a94\u0026#34;; objc_setAssociatedObject(obj, key, value, OBJC_ASSOCIATION_COPY_NONATOMIC); NSLog(@\u0026#34;name is: %@\u0026#34;, objc_getAssociatedObject(obj, key)); // name is: 0x1306a94 return 0; } 示例代码二, 为 category 实现 property\n#import \u0026lt;Foundation/Foundation.h\u0026gt; #import \u0026lt;objc/runtime.h\u0026gt; @interface CustomObject : NSObject @end @implementation CustomObject @end @interface CustomObject (Ext) @property (nonatomic, copy) NSString *name; @end @implementation CustomObject (Ext) static void *key = \u0026amp;key; // key 写法 - (void)setName:(NSString *)name { // objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_COPY_NONATOMIC); // 写法二,使用 getter selector, 推荐写法 objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC); } - (NSString *)name { // return objc_getAssociatedObject(self, key); // _cmd 为每个方法的第二个隐式参数, 推荐写法 return objc_getAssociatedObject(self, _cmd); } @end int main(int argc, const char *argv[]) { CustomObject *obj = [[CustomObject alloc] init]; obj.name = @\u0026#34;0x1306a94\u0026#34;; NSLog(@\u0026#34;name is: %@\u0026#34;, obj.name); // name is: 0x1306a94 return 0; } 源码窥探实现原理 本文基于 objc4-756.2.tar.gz 源码分析, 具体源码文件为 objc-references.mm\n首先是 objc_setAssociatedObject的原理 objc_setAssociatedObject 实际内部是调用的 _object_set_associative_reference\nvoid _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) { // This code used to work when nil was passed for object and key. Some code // probably relies on that to not crash. Check and handle it explicitly. // rdar://problem/44094390 // 如果被关联的对象和关联的值都没有,则什么也不做 if (!object \u0026amp;\u0026amp; !value) return; assert(object); // 检查被关联对象是否支持关联对象 if (object-\u0026gt;getIsa()-\u0026gt;forbidsAssociatedObjects()) _objc_fatal(\u0026#34;objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects\u0026#34;, object, object_getClassName(object)); // retain the new value (if any) outside the lock. // 用于记录旧的关联值 ObjcAssociation old_association(0, nil); // 如果 关联值有值则根据 policy 参数生成最终的关联值 id new_value = value ? acquireValue(value, policy) : nil; { AssociationsManager manager; // 获取全局的AssociationsHashMap AssociationsHashMap \u0026amp;associations(manager.associations()); // 将被关联对象的地址作为全局的 AssociationsHashMap 的key disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) { // 如果关联值 有值 // break any existing association. // 首先根据被关联对象地址从全局的 AssociationsHashMap 中查找 二级的 ObjectAssociationMap AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // secondary table exists // 如果找到了 二级的 ObjectAssociationMap ObjectAssociationMap *refs = i-\u0026gt;second; // 则再根据传入的key从二级的 ObjectAssociationMap 查找具体的关联值 ObjectAssociationMap::iterator j = refs-\u0026gt;find(key); if (j != refs-\u0026gt;end()) { // 如果找到 // 先记录旧的关联值 old_association = j-\u0026gt;second; // 然后再直接更新 关联值为新值 j-\u0026gt;second = ObjcAssociation(policy, new_value); } else { // 没有被设置过关联值,则直接设置关联值 (*refs)[key] = ObjcAssociation(policy, new_value); } } else { // create the new association (first time). // 如果没有找到 二级的 ObjectAssociationMap // 则先创建一个 二级的 ObjectAssociationMap ObjectAssociationMap *refs = new ObjectAssociationMap; // 将创建的 二级的 ObjectAssociationMap 添加到全局的 AssociationsHashMap 中 associations[disguised_object] = refs; // 再把关联值 添加到 二级的 ObjectAssociationMap 中 (*refs)[key] = ObjcAssociation(policy, new_value); // 标记被关联对象有关联对象 object-\u0026gt;setHasAssociatedObjects(); } } else { // 如果关联值为空 // setting the association to nil breaks the association. // 首先根据被关联对象地址从全局的 AssociationsHashMap 中查找 二级的 ObjectAssociationMap AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-\u0026gt;second; // 如果找到了 二级的 ObjectAssociationMap // 则再根据传入的key从二级的 ObjectAssociationMap 查找具体的关联值 ObjectAssociationMap::iterator j = refs-\u0026gt;find(key); if (j != refs-\u0026gt;end()) { // 记录旧的关联值 old_association = j-\u0026gt;second; // 从二级的 ObjectAssociationMap 中擦除 key 对应的关联值 refs-\u0026gt;erase(j); } } } } // release the old value (outside of the lock). // 如果旧的关联值有值, 则根据 policy 参数释放旧的关联值 if (old_association.hasValue()) ReleaseValue()(old_association); } 设置关联值流程图\nobjc_getAssociatedObject 原理 objc_getAssociatedObject 实际内部是调用的 _object_get_associative_reference\nid _object_get_associative_reference(id object, void *key) { id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; { AssociationsManager manager; // 获取全局的AssociationsHashMap AssociationsHashMap \u0026amp;associations(manager.associations()); // 将被关联对象的地址作为全局的 AssociationsHashMap 的key disguised_ptr_t disguised_object = DISGUISE(object); // 根据被关联对象地址从全局的 AssociationsHashMap 中查找 二级的 ObjectAssociationMap AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // 如果找到了 二级的 ObjectAssociationMap ObjectAssociationMap *refs = i-\u0026gt;second; // 则再根据传入的key从二级的 ObjectAssociationMap 查找具体的关联值 ObjectAssociationMap::iterator j = refs-\u0026gt;find(key); if (j != refs-\u0026gt;end()) { // 拿到最终的关联值 ObjcAssociation \u0026amp;entry = j-\u0026gt;second; value = entry.value(); policy = entry.policy(); // 根据 policy 值,判断是否需要进行 retain if (policy \u0026amp; OBJC_ASSOCIATION_GETTER_RETAIN) { objc_retain(value); } } } } // 检查是否需要进行 autorelease if (value \u0026amp;\u0026amp; (policy \u0026amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) { objc_autorelease(value); } // 返回查找到的 关联值 return value; } objc_removeAssociatedObjects 原理 objc_removeAssociatedObjects首先会检查 被关联对象是否有值, 是否被标记过有关联对象\nvoid objc_removeAssociatedObjects(id object) { if (object \u0026amp;\u0026amp; object-\u0026gt;hasAssociatedObjects()) { _object_remove_assocations(object); } } void _object_remove_assocations(id object) { // 记录所有的关联值 vector\u0026lt; ObjcAssociation,ObjcAllocator\u0026lt;ObjcAssociation\u0026gt; \u0026gt; elements; { AssociationsManager manager; // 首先拿到全局的 AssociationsHashMap AssociationsHashMap \u0026amp;associations(manager.associations()); // 如果全局的 AssociationsHashMap 中没有元素 则什么也不做 if (associations.size() == 0) return; // 将被关联对象的地址作为全局的 AssociationsHashMap 的key disguised_ptr_t disguised_object = DISGUISE(object); // 根据被关联对象地址从全局的 AssociationsHashMap 中查找 二级的 ObjectAssociationMap AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-\u0026gt;second; for (ObjectAssociationMap::iterator j = refs-\u0026gt;begin(), end = refs-\u0026gt;end(); j != end; ++j) { // 将二级的 ObjectAssociationMap 中的每一个元素,保存到 elements 中 elements.push_back(j-\u0026gt;second); } // remove the secondary table. // 释放二级的 ObjectAssociationMap 内存 delete refs; // 从全局的 AssociationsHashMap 中移除这个 二级的 ObjectAssociationMap associations.erase(i); } } // the calls to releaseValue() happen outside of the lock. // 释放从二级的 ObjectAssociationMap 中查找到的 所有关联值 for_each(elements.begin(), elements.end(), ReleaseValue()); } 总结: 实现关联对象的核心由 AssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation 组成 关联值并不是存储在被关联对象本身内存中 关联对象存储在全局的统一的一个 AssociationsManager 中 设置关联对象为 nil 就相当于是 移除关联值 "}),e.add({id:4,href:'/docs/',title:"Docs",content:""}),e.add({id:5,href:'/docs/wwdc22/ch01/01/',title:"运行时优化",content:"Message Send 优化 在Objective-C中的方法调用,最终都将转为objc_msgSend调用 根据其objc_msgSend调用约定其中第一个参数为receiver, 第二个参数为selector 如上图所示, 每次调用少不了selector准备, 优化之后 如上图所示,创建了selector对应的stub,将selector参数准备放到了stub中,这样一来stub就可以复用,同时也就少了很多获取selector的 adrp ldr指令,另一方面也就减小了可执行文件大小 同时这种优化有两种优化模式,如下图所示. Retain and release 在ARC中由编译器插入对应的内存处理代码,从而避免手动管理内存 在调用objc_retain objc_release前都需要准备x0寄存器.而优化的方式则是通过将参数准备调整为一系列objc_retain_xx objc_release_xx调用, 比如datComponents这个变量从分配到释放一直保持在x20寄存器中,那么在释放时则直接通过 bl _objc_release_x20,也就少了mov x0, x20这条指令,这种优化同样也减小了可执行文件大小 原session Improve app size and runtime performance "}),e.add({id:6,href:'/docs/llvm/ch02/02/',title:"基于 LibTooling 生成 C++ 的 Objective-C++ 包装接口想法初步验证",content:" 产生这个想法,源于一位大佬问我 Swift 调用 C++ 的解决方案是啥?\n已知方案 C 包装 C++ Objective-C++ 包装 C++ 上面两种方式都需收开发人员手动去写对应的包装接口,作为一个新生代的农民工,应该想办法自动的完成这件事,为自己挤出更多的摸鱼划水的时间。\n如何自动生成？ 之前在研究一个动态二维码code时,一开始是用Rust实现了一遍,然后通过Rust生成 ffi接口,以供iOS Android使用。Rust 通过在函数使用 extern \u0026quot;C\u0026quot; #[no_mangle]。然后通过 cbindgen 这类工具即可自动生成对应的 ffi 接口 所以我就想，能不能用类似的方式，在C++的类，函数上加点料，然后再通过一个工具，找出这些，自动生成对应的 Objective-C++ 答案是可以的， 可以利用 __attribute__((annotate())) 这个料又如何读出来呢？ AST 示例 #ifndef annotate_h #define annotate_h #define GEN_ANNOTATE_CLASS __attribute__((annotate(\u0026#34;native_gen_class\u0026#34;))) #define GEN_ANNOTATE_METHOD __attribute__((annotate(\u0026#34;native_gen_method\u0026#34;))) #define GEN_ANNOTATE_INCLUDE __attribute__((annotate(\u0026#34;native_gen_class_include\u0026#34;))) #endif /* annotate_h */ #ifndef kit_hpp #define kit_hpp #include \u0026lt;string\u0026gt; #include \u0026#34;annotate.h\u0026#34; using namespace std; namespace TT { struct GEN_ANNOTATE_CLASS GEN_ANNOTATE_INCLUDE Kit { int a = 0; GEN_ANNOTATE_METHOD bool vaild() const; }; }; // namespace TT class GEN_ANNOTATE_CLASS Kit2 { int a = 0; bool vaild() const; GEN_ANNOTATE_METHOD void test(string str); GEN_ANNOTATE_METHOD void test2(const char *str); }; #endif /* kit_hpp */ 打印AST clang++ -Xclang -ast-dump -fsyntax-only kit.cpp 可以看到图中的 AnnotateAttr `就是我们的加料 LibTooling 通过LibTooling解析源码AST,只要找到符合的AST我们就生成对应的Objective-C++源码， 具体怎么做呢？\n下载llvm源码 mkdir LLVM cd LLVM wget https://github.com/llvm/llvm-project/archive/refs/tags/llvmorg-13.0.0-rc1.zip unzip llvmorg-13.0.0-rc1.zip 创建工程\n在解压后的源码目录clang/examples目录下新建一个文件夹，如CppNativeGen clang/examples/CMakeLists.txt 追加一行 add_subdirectory(CppNativeGen) CppNativeGen 目录结构如下 CppNativeGen ├── CMakeLists.txt └── CppNativeGen.cpp CppNativeGen/MakeLists.txt 内容如下 add_clang_executable(cpp-native-gen CppNativeGen.cpp ) target_link_libraries(cpp-native-gen PRIVATE clangAST clangBasic clangDriver clangLex clangParse clangSema clangFrontend clangSerialization clangTooling clangToolingCore ) 生成Xcode工程\n辅助脚本 build.sh #!/usr/bin/env bash set -e set -o pipefail set -u ROOT_DIR=`pwd` SOURCE_CODE_DIR=$ROOT_DIR/llvm-project-llvmorg-13.0.0-rc1 BUILD_DIR=$ROOT_DIR/build_dir XCODE_BUILD_DIR=$BUILD_DIR/build_xcode XCODE_OUT_DIR=$BUILD_DIR/build_xcode_out function generate_xcode_project() { cd $XCODE_BUILD_DIR cmake -G \u0026#34;Xcode\u0026#34; \\ -DCMAKE_OSX_DEPLOYMENT_TARGET=\u0026#34;10.14\u0026#34; \\ -DCMAKE_OSX_SYSROOT=\u0026#34;macosx\u0026#34; \\ -DCMAKE_OSX_ARCHITECTURES=\u0026#39;x86_64;arm64\u0026#39; \\ -DLLVM_TARGETS_TO_BUILD=\u0026#34;ARM;X86\u0026#34; \\ -DCMAKE_BUILD_TYPE=Debug \\ -DCMAKE_INSTALL_PREFIX=$XCODE_OUT_DIR \\ -DLLVM_ENABLE_PROJECTS=\u0026#34;clang\u0026#34; \\ $SOURCE_CODE_DIR/llvm } function clear_build() { echo \u0026#34;clear build dir\u0026#34; rm -rf $BUILD_DIR } function onCtrlC () { clear_build exit 0 } trap \u0026#39;onCtrlC\u0026#39; INT mkdir -p $XCODE_BUILD_DIR generate_xcode_project 生成工程 chmod +x ./build.sh # 只需要执行一次 ./build.sh 打开build_dir/build_xcode/LLVM.xcodeproj\n打开后会提示创建Scheme, 选择手动， 将 cpp-native-gen 加上即可 CppNativeGen.cpp 源码\n//===- CppNativeGen.cpp ---------------------------------------------===// // // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions. // See https://llvm.org/LICENSE.txt for license information. // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception // //===----------------------------------------------------------------------===// // // Example clang plugin which simply prints the names of all the top-level decls // in the input file. // //===----------------------------------------------------------------------===// #include \u0026#34;clang/AST/AST.h\u0026#34; #include \u0026#34;clang/AST/ASTConsumer.h\u0026#34; #include \u0026#34;clang/AST/RecursiveASTVisitor.h\u0026#34; #include \u0026#34;clang/Frontend/CompilerInstance.h\u0026#34; #include \u0026#34;clang/Frontend/FrontendActions.h\u0026#34; #include \u0026#34;clang/Frontend/FrontendPluginRegistry.h\u0026#34; #include \u0026#34;clang/Sema/Sema.h\u0026#34; #include \u0026#34;clang/Tooling/CommonOptionsParser.h\u0026#34; #include \u0026#34;clang/Tooling/Tooling.h\u0026#34; #include \u0026#34;llvm/Support/CommandLine.h\u0026#34; #include \u0026#34;llvm/Support/Signals.h\u0026#34; #include \u0026#34;llvm/Support/raw_ostream.h\u0026#34; using namespace clang; namespace { static llvm::StringRef AnnotationClassName{\u0026#34;native_gen_class\u0026#34;}; static llvm::StringRef AnnotationMethodName{\u0026#34;native_gen_method\u0026#34;}; class CppNativeGenConsumer : public ASTConsumer { CompilerInstance \u0026amp;Instance; std::set\u0026lt;std::string\u0026gt; ParsedTemplates; public: CppNativeGenConsumer(CompilerInstance \u0026amp;Instance, std::set\u0026lt;std::string\u0026gt; ParsedTemplates) : Instance(Instance) , ParsedTemplates(ParsedTemplates) {} bool HandleTopLevelDecl(DeclGroupRef DG) override { for (DeclGroupRef::iterator i = DG.begin(), e = DG.end(); i != e; ++i) { const Decl *D = *i; // TODO: NamespaceDecl CXXRecordDecl 需要考虑 嵌套 if (const NamespaceDecl *NSD = dyn_cast\u0026lt;NamespaceDecl\u0026gt;(D)) { for (auto I : NSD-\u0026gt;decls()) { if (const CXXRecordDecl *RD = dyn_cast\u0026lt;CXXRecordDecl\u0026gt;(I)) { HandleCXXRecordDecl(RD); } } } else if (const CXXRecordDecl *RD = dyn_cast\u0026lt;CXXRecordDecl\u0026gt;(D)) { HandleCXXRecordDecl(RD); } } return true; } void HandleCXXRecordDecl(const CXXRecordDecl *RD) { if (RD-\u0026gt;hasAttr\u0026lt;AnnotateAttr\u0026gt;()) { AnnotateAttr *attr = RD-\u0026gt;getAttr\u0026lt;AnnotateAttr\u0026gt;(); if (attr-\u0026gt;getAnnotation() == AnnotationClassName) { llvm::errs() \u0026lt;\u0026lt; (RD-\u0026gt;isStruct() ? \u0026#34;annotation struct: \u0026#34; : \u0026#34;annotation class: \u0026#34;) \u0026lt;\u0026lt; RD-\u0026gt;getNameAsString() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; for (auto I : RD-\u0026gt;decls()) { if (const CXXMethodDecl *MD = dyn_cast\u0026lt;CXXMethodDecl\u0026gt;(I)) { HandleCXXMethodDecl(MD); } } } } } void HandleCXXMethodDecl(const CXXMethodDecl *MD) { // const CXXRecordDecl *RD = MD-\u0026gt;getParent(); if (MD-\u0026gt;hasAttr\u0026lt;AnnotateAttr\u0026gt;()) { AnnotateAttr *attr = MD-\u0026gt;getAttr\u0026lt;AnnotateAttr\u0026gt;(); if (attr-\u0026gt;getAnnotation() == AnnotationMethodName) { llvm::errs() \u0026lt;\u0026lt; \u0026#34;\\tmethod: \u0026#34; \u0026lt;\u0026lt; MD-\u0026gt;getNameAsString() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; auto numParams = MD-\u0026gt;getNumParams(); for (unsigned int i = 0; i \u0026lt; numParams; i++) { auto PD = MD-\u0026gt;getParamDecl(i); // PD-\u0026gt;dump(); QualType type = PD-\u0026gt;getType(); // if (true \u0026amp;\u0026amp; !type.isNull()) { // // If the type is sugared, also dump a (shallow) desugared type. // SplitQualType D_split = type.getSplitDesugaredType(); // if (T_split != D_split) // llvm::errs() \u0026lt;\u0026lt; \u0026#34;:\u0026#39;\u0026#34; \u0026lt;\u0026lt; QualType::getAsString(D_split, PrintPolicy) \u0026lt;\u0026lt; \u0026#34;\u0026#39;\u0026#34;; // } llvm::errs() \u0026lt;\u0026lt; \u0026#34;\\t\\tparam: name -\u0026gt; \u0026#34; \u0026lt;\u0026lt; PD-\u0026gt;getNameAsString() \u0026lt;\u0026lt; \u0026#34; type -\u0026gt; \u0026#34; \u0026lt;\u0026lt; QualType::getAsString(type.split(), PrintingPolicy{{}}) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } } }; class CppNativeGenAction : public PluginASTAction { std::set\u0026lt;std::string\u0026gt; ParsedTemplates; protected: std::unique_ptr\u0026lt;ASTConsumer\u0026gt; CreateASTConsumer(CompilerInstance \u0026amp;CI, llvm::StringRef) override { // 忽略警告 CI.getDiagnostics().setClient(new IgnoringDiagConsumer()); return std::make_unique\u0026lt;CppNativeGenConsumer\u0026gt;(CI, ParsedTemplates); } bool ParseArgs(const CompilerInstance \u0026amp;CI, const std::vector\u0026lt;std::string\u0026gt; \u0026amp;args) override { return true; } void PrintHelp(llvm::raw_ostream \u0026amp;ros) { ros \u0026lt;\u0026lt; \u0026#34;Help for CppNativeGen plugin goes here\\n\u0026#34;; } }; } // namespace // static FrontendPluginRegistry::Add\u0026lt;CppNativeGenAction\u0026gt; // X(\u0026#34;cpp-native-gen\u0026#34;, \u0026#34;print function names\u0026#34;); using namespace clang; using namespace tooling; using namespace llvm; static llvm::cl::OptionCategory OptsCategory(\u0026#34;cpp-native-gen\u0026#34;); int main(int argc, const char **argv) { // sys::PrintStackTraceOnErrorSignal(argv[0], false); // PrettyStackTraceProgram X(argc, argv); auto ExpectedParser = CommonOptionsParser::create(argc, argv, OptsCategory); if (!ExpectedParser) { llvm::errs() \u0026lt;\u0026lt; ExpectedParser.takeError(); return 1; } CommonOptionsParser \u0026amp;OptionsParser = ExpectedParser.get(); ClangTool Tool(OptionsParser.getCompilations(), OptionsParser.getSourcePathList()); // auto cmd = OptionsParser.getCompilations().getCompileCommands(OptionsParser.getSourcePathList().front()).front(); /* /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/xxx /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/clang 是对上面路径的软连 */ Tool.appendArgumentsAdjuster(getInsertArgumentAdjuster( \u0026#34;-I/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/clang/include\u0026#34;, ArgumentInsertPosition::END)); Tool.appendArgumentsAdjuster(getInsertArgumentAdjuster( \u0026#34;-I/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1\u0026#34;, ArgumentInsertPosition::END)); Tool.appendArgumentsAdjuster(getInsertArgumentAdjuster( \u0026#34;-I/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include\u0026#34;, ArgumentInsertPosition::END)); return Tool.run(clang::tooling::newFrontendActionFactory\u0026lt;CppNativeGenAction\u0026gt;().get()); } 在cpp-native-gen Edit Scheme 添加源码文件 运行即可看到控制台输出如下 剩下的就是，利用上面步骤收集的信息然后生成对应的Objective-C++源码，当然其中还是有很多细节的，比如参数类型的转换\n"}),e.add({id:7,href:'/docs/other/ffmpeg/ch01/01/',title:"iOS使用FFmepeg命令行工具源码实现转码功能",content:"1 编译FFmpeg 下载FFmpeg-iOS-build-script 修改脚本如下位置 # 可改可不改 SCRATCH=\u0026#34;scratch-ffmpeg\u0026#34; # 可改可不改 # must be an absolute path THIN=`pwd`/\u0026#34;thin-ffmpeg\u0026#34; # absolute path to x264 library #X264=`pwd`/fat-x264 #FDK_AAC=`pwd`/../fdk-aac-build-script-for-iOS/fdk-aac-ios # 修改 CONFIGURE_FLAGS 为如下 CONFIGURE_FLAGS=\u0026#34;--enable-cross-compile \\ --disable-debug \\ --disable-programs \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --disable-doc \\ --enable-pic \\ --disable-sdl2 \\ --enable-videotoolbox \\ --enable-avresample\u0026#34; # 只编译如下架构 ARCHS=\u0026#34;arm64 x86_64\u0026#34; 执行./build-ffmpeg.sh,等待编译完成,编译完成后再执行./build-ffmpeg.sh lipo合并所有架构的库 2 集成工程 将编译后的 静态库以及头文件导出工程, 并设置 HEADER SEARCH PATH 在项目中新建一个command-line文件夹\n新建config.h x86_64_config.h arm64_config.h\n在config.h中写入一下内容\n#if defined(__x86_64__) #include \u0026#34;x86_64_config.h\u0026#34; #else #include \u0026#34;arm64_config.h\u0026#34; #endif 在编译ffmepg 生成的 scratch目录将对于架构目录下的config.h文件内容拷贝上面对应的文件中 在ffmepg源码目录fftools目录中将以下文件导入工程中 在源码目录中搜索cmdutils_common_opts.h文件,同样导入工程\n在ffmpeg.h文件最后,添加以下代码\ntypedef void(*FFmpegCallBack)(int64_t, int64_t); int ffmpeg_main(int argc, char **argv, FFmpegCallBack callback); 修改ffmepg.c文件中int main(int argc, char **argv) 为 int ffmpeg_main(int argc, char **argv, FFmpegCallBack callback) 修改ffmpeg.c文件中static void ffmpeg_cleanup(int ret)函数 // 在 static void ffmpeg_cleanup(int ret) 函数末尾 添加以下代码 #warning 置空相关计数器 nb_filtergraphs = 0; nb_output_files = 0; nb_output_streams = 0; nb_input_files = 0; nb_input_streams = 0; 修改cmdutils.c文件,首先在头部导入#include \u0026lt;pthread/pthread.h\u0026gt; 然后修改void exit_program(int ret)函数 void exit_program(int ret) { if (program_exit) program_exit(ret); #warning 由于iOS应用是单进程,如果使用 exit 退出进程,则应用会被退出,因此改为退出线程 // exit(ret); pthread_exit(NULL); } 处理进度回调 // 修改 ffmpeg.c static int transcode(void) // 修改如下 static int transcode(FFmpegCallBack callback) // 修改 ffmpeg.c static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time) // 修改如下 static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time, FFmpegCallBack callback) // 在如下函数 static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time, FFmpegCallBack callback) // 1685 行位置 添加如下代码 int64_t total_frames_number = input_files[0]-\u0026gt;ctx-\u0026gt;streams[0]-\u0026gt;nb_frames; // 将 1716 ~ 1717 行代码改为如下代码 if (is_last_report) { if (callback != NULL) { (*callback)(total_frames_number, total_frames_number); } av_bprintf(\u0026amp;buf, \u0026#34;L\u0026#34;); } else { if (callback != NULL) { (*callback)((int64_t)frame_number, total_frames_number); } } 此时肯定是编译不通过的,因为还缺少文件, 在源码目录搜索以下文件,导入工程对应的位置 请注意导入对应源码目录中的文件 libavcodec/mathops.h libavcodec/arm/mathops.h libavcodec/x86/mathops.h libavutil/thread.h libavutil/libm.h libavutil/internal.h libavutil/timer.h libavutil/aarch64/timer.h libavutil/arm/timer.h libavutil/x86/timer.h libavutil/x86/asm.h libavutil/x86/emms.h libavutil/reverse.h libavformat/network.h libavformat/os_support.h libavformat/url.h compat/va_copy.h 3 如何使用 将Objective-C类型参数转为C类型参数,然后传入ffmpeg_main Video-Demo static NSDate *date = nil; static void __FFmpegCallBack(int64_t current, int64_t total) { NSLog(@\u0026#34;转码进度: %lld/%lld\u0026#34;, current, total); if ((current / total) \u0026gt;= 1) { int64_t time = (int64_t)([NSDate date].timeIntervalSince1970 - date.timeIntervalSince1970); int64_t hours = time % (24*3600) / 3600; int64_t minutes = time % 3600 / 60; int64_t second = time % 60; NSLog(@\u0026#34;转码完成, 耗时: %02lld:%02lld:%02lld\u0026#34;, hours, minutes, second); } } - (void)startFFmpeg:(NSArray\u0026lt;NSString *\u0026gt; *)commands { @autoreleasepool { int argc = (int)commands.count + 1; char **argv[argc]; argv[0] = \u0026#34;ffmpeg\u0026#34;; int idx = 1; for (NSString *cmd in commands) { argv[idx] = cmd.UTF8String; idx++; } NSString *finalCommand = [NSString stringWithFormat:@\u0026#34;ffmpeg 运行参数: \\nffmpeg %@\u0026#34;, [commands componentsJoinedByString:@\u0026#34; \u0026#34;]]; NSLog(@\u0026#34;%@\\n%@\u0026#34;, finalCommand, [NSThread currentThread].name); date = [NSDate date]; ffmpeg_main(argc, argv, \u0026amp;__FFmpegCallBack); } } // 使用 NSThread 线程调用 NSString *input_path = @\u0026#34;xxxx\u0026#34;; // 输入视频路径 NSString *ouput_path = @\u0026#34;xxxx\u0026#34;; // 输出视频路径 NSString *video_size = @\u0026#34;1920x1080\u0026#34;; // 输出视频尺寸 NSString *video_bit_rate = @\u0026#34;6000k\u0026#34;; // 输出视频码率 NSString *video_code = @\u0026#34;h264_videotoolbox\u0026#34;; // 视频编码器 NSString *video_frame_rate = @\u0026#34;30\u0026#34;; // 视频帧率 NSString *audio_bit_rate = @\u0026#34;64k\u0026#34;; // 音频码率 NSString *audio_sample_rate = @\u0026#34;44.1k\u0026#34;; // 音频采样率 NSString *audio_channels = @\u0026#34;1\u0026#34;; // 音频声道数 NSString *audio_code = @\u0026#34;aac\u0026#34;; // 音频编码器 NSArray\u0026lt;NSString *\u0026gt; *commands = @[@\u0026#34;-y\u0026#34;, @\u0026#34;-i\u0026#34;, input_path, @\u0026#34;-s\u0026#34;, video_size, @\u0026#34;-b:v\u0026#34;, video_bit_rate, @\u0026#34;-vcodec\u0026#34;, video_code, @\u0026#34;-r\u0026#34;, video_frame_rate, @\u0026#34;-b:a\u0026#34;, audio_bit_rate, @\u0026#34;-ar\u0026#34;, audio_sample_rate, @\u0026#34;-ac\u0026#34;, audio_channels, @\u0026#34;-acodec\u0026#34;, audio_code, ouput_path]; NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(startFFmpeg:) object:commands]; thread.name = @\u0026#34;ffmpeg.transcode.thread\u0026#34;; [thread start]; 测试视频信息,测试转码设备 iPhone X 64G 转码后视频信息 "}),e.add({id:8,href:'/docs/swift/ch01/01/',title:"Swift Substring",content:"Swift SubString 操作 import Foundation extension String { subscript(value: PartialRangeUpTo\u0026lt;Int\u0026gt;) -\u0026gt; Substring { get { return self[..\u0026lt;index(startIndex, offsetBy: value.upperBound)] } } subscript(value: PartialRangeThrough\u0026lt;Int\u0026gt;) -\u0026gt; Substring { get { return self[...index(startIndex, offsetBy: value.upperBound)] } } subscript(value: PartialRangeFrom\u0026lt;Int\u0026gt;) -\u0026gt; Substring { get { return self[index(startIndex, offsetBy: value.lowerBound)...] } } subscript(value: CountableRange\u0026lt;Int\u0026gt;) -\u0026gt; Substring { get { let start = index(self.startIndex, offsetBy: value.lowerBound) let end = index(self.startIndex, offsetBy: value.upperBound) return self[start..\u0026lt;end] } } subscript(value: ClosedRange\u0026lt;Int\u0026gt;) -\u0026gt; Substring { get { let start = index(self.startIndex, offsetBy: value.lowerBound) let end = index(self.startIndex, offsetBy: value.upperBound) return self[start...end] } } } let str = \u0026#34;hello\u0026#34; // PartialRangeFrom print(str[1...]) // ello // PartialRangeThrough print(str[...3]) // hell // PartialRangeUpTo print(str[..\u0026lt;3]) // hel // ClosedRange print(str[1...3]) // ell // CountableRange print(str[1..\u0026lt;3]) // el "}),e.add({id:9,href:'/readme/',title:"Readme",content:"blog-content "}),e.add({id:10,href:'/categories/',title:"Categories",content:""}),e.add({id:11,href:'/tags/',title:"Tags",content:""}),e.add({id:12,href:'/',title:"序章",content:"记录\u0026hellip;\n"})})()